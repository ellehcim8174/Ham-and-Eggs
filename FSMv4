; FSMv4.asm
; fsm with states, timer 1 interrupt added in, states moved to another file
$MODLP52
$NOLIST

button				equ P2.6		; button
SSR_Power			equ P3.7		; pin to turn on or off solid state relay
coolTmp				equ 40			; temperature to cool to to be safe to handle
CLK					equ 22118400	; Microcontroller system crystal frequency in Hz
TIMER1_RATE			equ 1000		; 1000Hz, for a timer tick of 1ms
TIMER1_RELOAD		equ ((65536-(CLK/TIMER1_RATE)))

$NOLIST
$include(LCD_4bit.inc)			; library of LCD functions
$include(FSMinclude.inc)		; macros for the FSM
$include(FSMincludeStates.inc)
$LIST

DSEG at 30H
; user defined variables
soakTime:			ds 1		; time to soak
soakTmp:			ds 1		; temperature to soak at
reflowTime:			ds 1		; time to reflow for
reflowTmp:			ds 1		; temperature to reflow at
state:				ds 1		; which state
TICKS:				ds 2		; timer

currTmp:			ds 1		; current temperature, from temp sensor
timerCount:			ds 2		; timer count from timer (how many seconds in each stage)

; These 'equ' must match the wiring between the microcontroller and the LCD!
LCD_RS equ P1.4
LCD_RW equ P1.5
LCD_E  equ P1.6
LCD_D4 equ P3.2
LCD_D5 equ P3.3
LCD_D6 equ P3.4
LCD_D7 equ P3.5

bseg
start:				dbit 1		; start = 1
chkbit:				dbit 1		; true = 1, false = 0

cseg
org 0000H
   ljmp MainProgram
; External interrupt 1 vector (not used in this code)
org 0013H
 reti 
; Timer/Counter 1 overflow interrupt vector
org 001BH
 ljmp Timer1_ISR

; Routine to initialize the ISR
Timer1_Init:
	clr TR1   ; turn off timer
	mov a, TMOD  
	anl a, #0x0Fh ; clear bits for timer 1
	orl a, #0x10h ; Configure timer 1 as 16-timer
	mov TMOD, a

	mov TH1, #high(TIMER1_RELOAD)
	mov TL1, #low(TIMER1_RELOAD)
	clr TF1   ; clear timer flag
	; Enable the timer and interrupts
	setb ET1  ; Enable timer 0 interrupt
    setb TR1  ; Start timer 0
    setb EA   ; Enable Global interrupts
 ret

; ISR for timer 1
Timer1_ISR:
	clr TR1   ; stop the timer
	; The two registers used in the ISR must be saved in the stack
	push acc
	push psw 
	mov TH1, #high TIMER1_RELOAD
	mov TL1, #low TIMER1_RELOAD 
	setb TR1 ; start timer
	
	; Increment the 16-bit counter
	inc TICKS+0    ; Increment the low 8-bits first
	mov a, TICKS+0 ; If the low 8-bits overflow, then increment high 8-bits
	jnz Inc_Done
	inc TICKS+1
 
Inc_Done:
	; Check if 1000 milli-seconds had passed
	mov a, TICKS+0
	cjne a, #low(1000), EXIT
	mov a, TICKS+1
	cjne a, #high(1000), EXIT
	; Re-start tick counter
	mov TICKS+0, #0
	mov TICKS+1, #0

timeRuns: 
	; Increment time
	increment_BCD(timerCount)
EXIT:
 pop PSW     ; restore PSW register
 pop ACC     ; restore ACC register
 reti

; status messages
Stage: db 'Stage:', 0
StartMessage: db 'Start?', 0
Ramp: db 'Ramp', 0
Soak: db 'Soak', 0
Peak: db 'Peak', 0
Reflow: db 'Reflow', 0
Cool: db 'Cooling', 0

starts:
	Wait_Milli_Seconds(#50)
	jnb P2.4, $
	cpl start
	Wait_Milli_Seconds(#50)
	sjmp Forever

MainProgram:
    mov SP, #7FH
    mov PMOD, #0 ; Configure all ports in bidirectional mode
    clr SSR_Power
    lcall LCD_4BIT
    clr start
    clr chkbit

	mov soakTmp, #40
	mov currTmp, #30
	mov soakTime, #22
	Set_Cursor(1,1)
	Send_Constant_String(#StartMessage)
Forever: 
	ljmp state0
	sjmp Forever
        
END
