; FSMv1.asm
; FSM code with states

$MODLP52
$NOLIST  

SSR_Power         equ P3.7
coolTmp            equ 40
CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
TIMER1_RATE   EQU 1000    ; 1000Hz, for a timer tick of 1ms
TIMER1_RELOAD EQU ((65536-(CLK/TIMER1_RATE)))

DSEG at 30H
; user defined variables
soakTime:          ds 2
soakTmp:           ds 2
reflowTime:        ds 2
reflowTmp:        ds 2
state:                ds 1
TICKS:            ds 2

currTmp:            ds 1                ; from temp sensor
timerCount:            ds 2            ; from timer


cseg
org 0000H
   ljmp MainProgram
; External interrupt 1 vector (not used in this code)
org 0013H
 reti 
; Timer/Counter 1 overflow interrupt vector
org 001BH
 ljmp Timer1_ISR

; These 'equ' must match the wiring between the microcontroller and the LCD!
LCD_RS equ P1.4
LCD_RW equ P1.5
LCD_E  equ P1.6
LCD_D4 equ P3.2
LCD_D5 equ P3.3
LCD_D6 equ P3.4
LCD_D7 equ P3.5

$NOLIST
$include(LCD_4bit.inc)            ; library of LCD functions
$include(FSMinclude.h) 
$LIST



bseg
start:        dbit 1
chkbit:            dbit 1            ; true = 1, false = 0


; status messages
Stage: db 'Stage:', 0
StartMessage: db 'Start?', 0
Ramp: db 'Ramp', 0
Soak: db 'Soak', 0
Peak: db 'Peak', 0
Reflow: db 'Reflow', 0
Cool: db 'Cooling', 0

;---------------------------------;
; Routine to initialize the ISR   ;
; for timer 1                     ;
;---------------------------------;

Timer1_Init:
 clr TR1   ; turn off timer
 mov a, TMOD  
 anl a, #0x0Fh ; clear bits for timer 1
 orl a, #0x10h ; Configure timer 1 as 16-timer
 mov TMOD, a

 mov TH1, #high(TIMER1_RELOAD)
 mov TL1, #low(TIMER1_RELOAD)
 clr TF1   ; clear timer flag
 ; Enable the timer and interrupts
    setb ET1  ; Enable timer 0 interrupt
    setb TR1  ; Start timer 0
    setb EA   ; Enable Global interrupts
 ret


; A little macro to increment BCD variables
increment_BCD mac
 mov a, %0
 add a, #1
 da a
 mov %0, a
endmac

;---------------------------------;
; ISR for timer 1                 ;
;---------------------------------;
Timer1_ISR:
 clr TR1   ; stop the timer
 ; The two registers used in the ISR must be saved in the stack
 push acc
 push psw 
 mov TH1, #high TIMER1_RELOAD
 mov TL1, #low TIMER1_RELOAD 
 setb TR1 ; start timer

 

 ; Increment the 16-bit counter
 inc TICKS+0    ; Increment the low 8-bits first
 mov a, TICKS+0 ; If the low 8-bits overflow, then increment high 8-bits
 jnz Inc_Done
 inc TICKS+1
 
Inc_Done:
 ; Check if 1000 milli-seconds had passed
 mov a, TICKS+0
 cjne a, #low(1000), GOEXIT
 mov a, TICKS+1
 cjne a, #high(1000), GOEXIT
 ; Re-start tick counter
 mov TICKS+0, #0
 mov TICKS+1, #0

 
timeRuns: 
 ; Increment time
 increment_BCD(timerCount)

EXIT:
 pop PSW     ; restore PSW register
 pop ACC     ; restore ACC register
 reti


; FSM states
; process has not started yet; user can input desired temp, time, etc.
; default state for reset
state0:

    Set_Cursor(1,1)

    Send_Constant_String (#Stage)

    ; set power = 0

    jb start, state1        ; if start = 1, jump to state 1

    ljmp state0




; ramp to soak stage

; 100% power; stays in state until current temperature reaches soak temperature

state1:

 inc currTmp
    jnb start, jumpstate0            ; if start = 0, reset to state 0
    Power_Percentage(#100)        ; set power = 100%
    Wait_Milli_Seconds(#250)
    Wait_Milli_Seconds(#250)
    Set_Cursor(1,8)
    Send_Constant_String(#Ramp)
    ; set sec = 0
    ; compare if temp <= 150
    BLE(currTmp, soakTmp)           ; check if currTmp <= soakTmp
    jb chkbit, $                              ; if true, loop
    sjmp state2                            ; else cont states


; jump label to go to state0    
jumpstate0:
 ljmp state0
    
; at preheat/soak state
; stays in this state until soak time has been reached (20% power0
state2:
    jnb start, jumpstate0            ; if start pressed, reset to state0

    cjne a, #2, state3        ; check if state = 2

    Set_Cursor(1,8)

    Send_Constant_String(#Soak)

    Power_Percentage(#20)

   BLE(timerCount, soakTime)           ; check if timerCount < = soakTime

    jb chkbit, $                              ; if true, loop

    sjmp state3                            ; else cont states




jump2state0:

 ljmp state0




; ramp to peak state

; 100% power, stays in state until selected reflow temperature has been reached

state3:

    Power_Percentage(#100)    ; put 100% power

     Set_Cursor(1,8)

    Send_Constant_String(#Peak)

    jnb start, jump2state0        ; if start = 0, reset to state 0

    BLE(currTmp, reflowTmp)           ; check if currTmp <= reflowTmp

    jb chkbit, $                              ; if true, loop

    sjmp state4                            ; else cont states




; reflow stage

; 20% power, stays in stage until selected reflow time has been reached

state4:

    Power_Percentage(#20); set power = 20%

    ; if timerCount <= reflowTime, loop

     Set_Cursor(1,8)

    Send_Constant_String(#Reflow)

    BLE(timerCount, reflowTime)           ; check if timerCount <= reflowTime

    jb chkbit, $                              ; if true, loop

    sjmp state5                            ; else cont states




; cooling stage

; 0% power, stays in stage until current temperature has dropped to 60

state5:

    ; set power = 0%

    ; if temp >= 60C, loop (code is same as <= except for jump to state 0

    Set_Cursor(1,8)

    Send_Constant_String(#Cool)

    BGE(currTmp, #coolTmp)           ; check if currTmp <= coolTmp

    jb chkbit, $                              ; if true, loop

    ljmp state0                            ; else cont states



MainProgram:

    mov SP, #7FH

    mov PMOD, #0 ; Configure all ports in bidirectional mode

    clr SSR_Power

    lcall timer1_init		




 mov soakTmp, #40

 mov currTmp, #30

Forever:        

 ljmp state1

 sjmp Forever

        

END


