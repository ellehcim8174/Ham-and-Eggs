; FSMv3.asm
; fsm with states, timer 1 interrupt added in
$MODLP52
$NOLIST

button				equ P2.6		; button
SSR_Power			equ P3.7		; pin to turn on or off solid state relay
coolTmp				equ 40			; temperature to cool to to be safe to handle
CLK					equ 22118400	; Microcontroller system crystal frequency in Hz
TIMER1_RATE			equ 1000		; 1000Hz, for a timer tick of 1ms
TIMER1_RELOAD		equ ((65536-(CLK/TIMER1_RATE)))

$NOLIST
$include(LCD_4bit.inc)			; library of LCD functions
$include(FSMinclude.inc)		; macros for the FSM
$LIST

DSEG at 30H
; user defined variables
soakTime:			ds 1		; time to soak
soakTmp:			ds 1		; temperature to soak at
reflowTime:			ds 1		; time to reflow for
reflowTmp:			ds 1		; temperature to reflow at
state:				ds 1		; which state
TICKS:				ds 2		; timer

currTmp:			ds 1		; current temperature, from temp sensor
timerCount:			ds 2		; timer count from timer (how many seconds in each stage)

; These 'equ' must match the wiring between the microcontroller and the LCD!
LCD_RS equ P1.4
LCD_RW equ P1.5
LCD_E  equ P1.6
LCD_D4 equ P3.2
LCD_D5 equ P3.3
LCD_D6 equ P3.4
LCD_D7 equ P3.5

bseg
start:				dbit 1		; start = 1
chkbit:				dbit 1		; true = 1, false = 0

cseg
org 0000H
   ljmp MainProgram
; External interrupt 1 vector (not used in this code)
org 0013H
 reti 
; Timer/Counter 1 overflow interrupt vector
org 001BH
 ljmp Timer1_ISR

; Routine to initialize the ISR
Timer1_Init:
	clr TR1   ; turn off timer
	mov a, TMOD  
	anl a, #0x0Fh ; clear bits for timer 1
	orl a, #0x10h ; Configure timer 1 as 16-timer
	mov TMOD, a

	mov TH1, #high(TIMER1_RELOAD)
	mov TL1, #low(TIMER1_RELOAD)
	clr TF1   ; clear timer flag
	; Enable the timer and interrupts
	setb ET1  ; Enable timer 0 interrupt
    setb TR1  ; Start timer 0
    setb EA   ; Enable Global interrupts
 ret

; ISR for timer 1
Timer1_ISR:
	clr TR1   ; stop the timer
	; The two registers used in the ISR must be saved in the stack
	push acc
	push psw 
	mov TH1, #high TIMER1_RELOAD
	mov TL1, #low TIMER1_RELOAD 
	setb TR1 ; start timer
	
	; Increment the 16-bit counter
	inc TICKS+0    ; Increment the low 8-bits first
	mov a, TICKS+0 ; If the low 8-bits overflow, then increment high 8-bits
	jnz Inc_Done
	inc TICKS+1
 
Inc_Done:
	; Check if 1000 milli-seconds had passed
	mov a, TICKS+0
	cjne a, #low(1000), EXIT
	mov a, TICKS+1
	cjne a, #high(1000), EXIT
	; Re-start tick counter
	mov TICKS+0, #0
	mov TICKS+1, #0

timeRuns: 
	; Increment time
	increment_BCD(timerCount)
EXIT:
 pop PSW     ; restore PSW register
 pop ACC     ; restore ACC register
 reti

; FSM states
; process has not started yet; user can input desired temp, time, etc.
; default state for reset
state0:
	jnb P2.4, starts1
    Set_Cursor(1,1)
    Send_Constant_String (#Stage)
    Power_Percentage(#0)
    jb start, state1        ; if start = 1, jump to state 1
    ljmp state0
    
starts1: ljmp starts

; ramp to soak stage
; 100% power; stays in state until current temperature reaches soak temperature
bpressed:
	Wait_Milli_Seconds(#50)
	jnb button, $
	mov currTmp, #50
	sjmp s1cont
	
state1:
	jnb start, jumpstate0			; if start = 0, reset to state 0
	Power_Percentage(#100)			; set power = 100%
	Wait_Milli_Seconds(#250)
	Wait_Milli_Seconds(#250)
	Set_Cursor(1,8)
	Send_Constant_String(#Ramp)
	; set sec = 0
	; compare if temp <= 150
	jnb button, bpressed
s1cont:
	BLE(currTmp, soakTmp)			; check if currTmp <= soakTmp
	jb chkbit, state1				; if true, loop
	sjmp state2						; else cont states

; jump label to go to state0    
jumpstate0:
	ljmp state0
    
; at preheat/soak state
; stays in this state until soak time has been reached (20% power0
state2:
    jnb start, jumpstate0					; if start pressed, reset to state0
    cjne a, #2, state3						; check if state = 2
    Set_Cursor(1,8)
    Send_Constant_String(#Soak)
    Power_Percentage(#20)
   	BLE(#timerCount, soakTime)				; check if timerCount < = soakTime
    jb chkbit, $							; if true, loop
    sjmp state3								; else cont states

jump2state0:
	ljmp state0

; ramp to peak state
; 100% power, stays in state until selected reflow temperature has been reached
state3:
    Power_Percentage(#100)					; put 100% power
    Set_Cursor(1,8)
    Send_Constant_String(#Peak)
    jnb start, jump2state0					; if start = 0, reset to state 0
    BLE(currTmp, reflowTmp)					; check if currTmp <= reflowTmp
    jb chkbit, $							; if true, loop
    sjmp state4								; else cont states

; reflow stage
; 20% power, stays in stage until selected reflow time has been reached
state4:
    Power_Percentage(#20); set power = 20%
    ; if timerCount <= reflowTime, loop
	Set_Cursor(1,8)
    Send_Constant_String(#Reflow)
    BLE(#timerCount, reflowTime)			; check if timerCount <= reflowTime
    jb chkbit, $							; if true, loop
    sjmp state5								; else cont states

; cooling stage
; 0% power, stays in stage until current temperature has dropped to 60
state5:
    ; set power = 0%
    ; if temp >= 60C, loop (code is same as <= except for jump to state 0
    Set_Cursor(1,8)
    Send_Constant_String(#Cool)
    BGE(currTmp, #coolTmp)					; check if currTmp <= coolTmp
    jb chkbit, $							; if true, loop
    ljmp state0								; else cont states

; status messages
Stage: db 'Stage:', 0
StartMessage: db 'Start?', 0
Ramp: db 'Ramp', 0
Soak: db 'Soak', 0
Peak: db 'Peak', 0
Reflow: db 'Reflow', 0
Cool: db 'Cooling', 0

starts:
	Wait_Milli_Seconds(#50)
	jnb P2.4, $
	cpl start
	Wait_Milli_Seconds(#50)
	sjmp Forever

MainProgram:
    mov SP, #7FH
    mov PMOD, #0 ; Configure all ports in bidirectional mode
    clr SSR_Power
    lcall LCD_4BIT
    clr start
    clr chkbit


	mov soakTmp, #40
	mov currTmp, #30
	mov soakTime, #22
	Set_Cursor(1,1)
	Send_Constant_String(#StartMessage)
Forever: 
	ljmp state0
	sjmp Forever
        
END
