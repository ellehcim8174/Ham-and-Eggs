; FSMinclude.h
; macros
$NOLIST
CSEG

; macro to do PWM
; recieves power percentage, turns on for that number of milliseconds, off for 100 minus that percentage
Power_Percentage mac
    setb SSR_Power                ; turn on power
    mov a, %0
    mov b, #10
    div ab
wait:
    lcall WaitHalfSec      ; leave power on for percentage number of milliseconds
    lcall WaitHalfSec
    dec a
    jnz wait
    
    clr SSR_Power                    ; turn off power
    mov a, #100
    subb a, %0
    mov b, #10
    div ab
wait2:
    lcall WaitHalfSec   ;  leave power off for 100-percentage number of milliseconds
	lcall WaitHalfSec

	dec a
	jnz wait2
endmac

; macro for value >= chk and returns chkbit = true/false
; BGE(value,chk)
BGE mac
    clr chkbit                                    ; clear chkbit
    clr c                                        ; clear carry
    mov a, %0                            ; mov a, value
    subb a, %1                            ; subtract check with value
    lcall ?BGE
endmac
?BGE:
	jz BGE_true			; if acc = 0, true
	jc BGE_true			; if carry = 0, true
	sjmp BGE_done
BGE_true:
	setb chkbit			; true, so return chkbit = 1
BGE_done:
	ret

; macro for value <= chk and returns chkbit = true/false
; BLE(value,chk)
BLE mac
	Set_Cursor(2,1)
    clr chkbit                                    ; clear chkbit
    clr c                                        ; clear carry
    mov a, %0                            ; mov a, value
    subb a, %1                            ; subtract value by chk
    lcall ?BLE
endmac

?BLE:
    jz BLE_true			            ; if acc = 0, true
	jc BLE_true						; if carry = 1, true
    sjmp BLE_done                   ; else finish macro
BLE_true:
	setb chkbit						; true, set return chkbit = 1
BLE_done:
	ret

; A little macro to increment BCD variables
increment_BCD mac
 mov a, %0
 add a, #1
 da a
 mov %0, a
endmac
